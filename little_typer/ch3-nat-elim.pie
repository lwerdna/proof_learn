#lang pie

;; Exercises on using Nat eliminators from Chapter 3 of The Little Typer
;;
;; Some exercises are adapted from assignments at Indiana University

;; Exercise 3.1
;;
;; Define a function called at-least-two? that takes one Nat argument and evaluates to an Atom.
;;
;; at-least-two? evaluates to 't if the Nat is greater than or equal to 2 otherwise it evaluates to 'nil.
;;
;; Note: The only Nat eliminator you should need in the body of at-least-two? is which-Nat.

;; version #1: use nested which-Nat

(claim at-least-two?
	(-> Nat
		Atom))
(define at-least-two?
	(lambda (x)
		(which-Nat x
			'nil	; if x was 0
			(lambda (x)
				(which-Nat x
					'nil ; if x was 1
					(lambda (x) 't))))))

(check-same Atom (at-least-two? 4) 't)
(check-same Atom (at-least-two? 3) 't)
(check-same Atom (at-least-two? 2) 't)
(check-same Atom (at-least-two? 1) 'nil)
(check-same Atom (at-least-two? 0) 'nil)

;; version #2: use a sub1 function

(claim sub1
	(-> Nat Nat))
(define sub1
	(lambda (x)
		(which-Nat x
			0
			(lambda (k) k))))

(check-same Nat (sub1 5) 4)
(check-same Nat (sub1 1) 0)
(check-same Nat (sub1 0) 0)

(claim _at-least-two?
	(-> Nat
		Atom))
(define _at-least-two?
	(lambda (x)
		(which-Nat (sub1 x)
			'nil	; if x was 0
			(lambda (x) 't))))

(check-same Atom (_at-least-two? 4) 't)
(check-same Atom (_at-least-two? 3) 't)
(check-same Atom (_at-least-two? 2) 't)
(check-same Atom (_at-least-two? 1) 'nil)
(check-same Atom (_at-least-two? 0) 'nil)

;; Exercise 3.2
;;
;; Rewrite the definition of + (in frame 3.27) using the rec-Nat eliminator instead of the iter-Nat eliminator.

(claim +
	(-> Nat Nat
		Nat))
(define +
	(lambda (a b)
		(iter-Nat a
			b
			(lambda (subresult) (add1 subresult)))))

(check-same Nat (+ 1 4) 5)
(check-same Nat (+ 3 1) 4)
(check-same Nat (+ 0 9) 9)
(check-same Nat (+ 11 12) 23)
(check-same Nat (+ 5 6) 11)

;; Exercise 3.3
;;
;; Define a function called exp that takes two Nat arguments and evaluates to a Nat.
;;
;; exp evaluates to the exponentiation, a^b, of the two passed arguments.

(claim *
	(-> Nat Nat
		Nat))
(define *
	(lambda (a b)
		(iter-Nat a
			0
			(lambda (subresult) (+ subresult b)))))

(check-same Nat (* 1 4) 4)
(check-same Nat (* 3 1) 3)
(check-same Nat (* 0 9) 0)
(check-same Nat (* 11 12) 132)
(check-same Nat (* 5 6) 30)

(claim exp
	(-> Nat Nat
		Nat))
(define exp
	(lambda (b e)
		(iter-Nat e
			1
			(lambda (subresult) (* subresult b)))))

(check-same Nat (exp 1 4) 1)
(check-same Nat (exp 3 1) 3)
(check-same Nat (exp 0 9) 0)
(check-same Nat (exp 9 0) 1)
(check-same Nat (exp 2 8) 256)
;(check-same Nat (exp 5 6) 15625)

;; Exercise 3.4
;;
;; Define a function called max that takes two Nat arguments and evaluates to a Nat.
;;
;; max evaluates to the larger of the two passed arguments.

(claim is-zero?
	(-> Nat
		Atom))
(define is-zero?
	(lambda (x)
		(which-Nat x
			't
			(lambda (k) 'nil))))
(check-same Atom (is-zero? 1) 'nil)
(check-same Atom (is-zero? 3) 'nil)
(check-same Atom (is-zero? 0) 't)
(check-same Atom (is-zero? 9) 'nil)

(claim max
	(-> Nat Nat
		Nat))

		
