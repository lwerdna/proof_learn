(* type of day is Type *)
(* sun, mon, ... is a "constructor" *)
(* inductive type also called invariant type *)
Inductive day : Type :=
| sun : day
| mon : day
| tue : day
| wed : day
| thu : day
| fri : day
| sat : day.

Definition next_day d :=
  match d with
  | sun => mon
  | mon => tue
  | tue => wed
  | wed => thu
  | thu => fri
  | fri => sat
  | sat => sun
  end.
  
Definition prev_day d :=
  match d with
  | sun => sat
  | mon => sun
  | tue => mon
  | wed => tue
  | thu => wed
  | fri => thu
  | sat => fri
  end.

(* most basic proof...
  prove f(x) = y  for some x,y
  proof is by simply "executing" it *)
Theorem wed_after_tue : next_day tue = wed.
Proof.
  Show Proof.
  simpl.
  Show Proof.
  reflexivity.
  (* or auto *)
  Show Proof.
Qed.

(* print the proof term *)
Print wed_after_tue.
Check wed_after_tue. (* just prints proof statement *)
Print eq_refl.

(* this works: *)
Check eq (next_day tue) wed.

(* this doesn't, dunno why yet *)
(* Check eq_refl (next_day tue) wed. *)

Check eq 5 5.
Check eq_refl (eq 5 5).

(* RECAP

  most basic proof: f(x) = y

  how? call eq with f(x) and y as arguments

  that can be sent to eq_refl to also allow y = f(x)
*)

(* introducing FORALL *)
Theorem day_never_repeats : forall d : day, next_day d <> d.

Proof. 
intros d. (* let d be some arbitrary day *)
destruct d. (* do case analysis (undo constructor)
              generates #constructor subgoals *)
simpl.
discriminate. (* proves different constructors cannot be equal *)
simpl. discriminate.
simpl. discriminate.
(* all says to do something on all the remaining subgoals *)
all: discriminate.
Qed.

(* "tactical" semicolon t1;t2 means apply tactic t1, then apply t2
  to all subgoals generated by t1 *)

(* prove a fact about input given an output
  prove f(x) = y -> x = ??? *)
Theorem mon_preceds_tues : forall d : day,
  next_day d = tue -> d = mon.
Proof.
  intros d. (* assume/let d be a day *)
  (* now we are using implication introduction inference rule
    we want A -> B
    so we assume A, and only have to mark B true when A is true
    concluding A *)
  intros H. (* the antecedent of a -> b,
                            next_day d = tue *)
  destruct d. (* unconstruct d *)
  
  (* 1st case: d = sun
                 antecedent: next_day d = tue (FALSE)
                 consequent: sun = mon (FALSE)
     FALSE -> ??? does not disconfirm A -> B *)
  discriminate.
  (* 2nd case: d = mon
                 antecedent: next_day d = tue (TRUE)
                 consequent: mon = mon (TRUE)
     TRUE -> TRUE must confirm A -> B *)
  simpl.  
  reflexivity.
  (* 3rd case: d = tue
                 antecedent: next_day d = tue (FALSE)
                 consequent: tue = mon (FALSE)  
     FALSE -> ??? does not disconfirm A -> B *)
  discriminate.
  (* 4th, 5th, 6th, 7th case ... *)
  all: discriminate.
Qed.

(* RECAP:
  to prove A -> B we did case-by-case analysis on a variable
  in the hypothesis (d) and informed Coq of true cases when
  A was true and B was too
  
  implication introduction *)
  
Module MyList.

Inductive list (A : Type) : Type :=
| nil : list A (* nil is a list, for any type A *)
| cons : A -> list A -> list A. (* cons takes an A, a list A, and returns list A *)

End MyList.

(* returns Type -> Type ... I think that's taking any type A
  and returning type list *)
Check list.

Check (list nat).
Check nil. (* has type list ?A and implicit type argument *)
(* are implicit type argument those that are inferred? *)
(* Check nil nat. (* why can't nat be the type argument? *) *)
Check cons.
(* make some lists *)
Check (cons 4 nil).
Check (cons 1 (cons 2 (cons 3 (cons 4 nil)))).
(* where the hell are the values 1,2,3,4 actually stored? *)
Check list nat. (* I think "list nat" is a type now, or a : Set, whatever *)
Check list bool. (* is "list bool" now a type? *)

Definition one_to_four: list nat := (cons 1 (cons 2 (cons 3 (cons 4 nil)))).
Check one_to_four.

Definition is_empty_nat (lst : list nat) :=
  match lst with
  | nil => true
  | cons _ _ => false
  end.

Check is_empty_nat one_to_four.
Compute is_empty_nat one_to_four.

(* ok here is the generic one *)
Definition is_empty (A : Type) (lst : list A) :=
  match lst with
  | nil => true
  | cons _ _ => false
  end.

(* won't work, takes two arguments! *)
(* Compute is_empty one_to_four. *)
(* nat is explicit type argument *)
Compute is_empty nat one_to_four.

(* something that the compiler infers, instead of the programmer having to provide. These are called implicit arguments *)
(* A is not implicit type argument *)
Definition is_empty' {A : Type} (lst : list A) :=
  match lst with
  | nil => true
  | cons _ _ => false
  end.

Compute is_empty' (cons 1 nil).

(* compare explicit type argument: *)
Check is_empty.
(* forall A : Type, list A -> bool
  for all values of A, a type, so for all types... *)
Check is_empty'.
(* : list ?A -> bool *)

(* doesn't work, need type *) 
(* Check is_empty [1]. *)
Check is_empty nat (cons 1 nil).

(* [] is syntactic sugar for nil
  :: is syntactic sugar for cons *)

(* option type

If ideal functions are always supposed to return something, how do you square that with practical need to optionally return something?

You wrap the return type in an additional type called an option type: 
*)
Module MyOption.

(* new types "option Nat" with values "Some", "None"
             "option Bool" with values "Some", "None" *)
Inductive option (A:Type) : Type :=
  | Some : A -> option A
  | None : option A.

End MyOption.

Check option nat.
Check option bool.

Check Some.
Check Some nat. (* ok, functional construction *)
(* Check None nat. *) (* not ok - must be inferred I think *)
Check Some bool.


Definition foo : Type := option nat.
Definition foo2 : option nat := Some 5.
Definition foo3 : option nat := None.

(* (A : Type) is like a Haskell type constraint or class constraint
   {A : Type) is same, but implied (coq should infer it)
   
   head_opt maps list -> option *)
Definition head_opt {A : Type} (lst : list A) : option A :=
  match lst with
  | nil => None
  | cons x y => Some x
  end.

(* head_opt : list ?A -> option ?A *)
Check head_opt.

Compute head_opt (cons 1 nil).

(* @ means we force-feed the type inference, we give it an explicit
  type when it expects an implicit type *)
Compute @head_opt nat nil.

Compute head_opt nil.

(* suppose A is "nat"
      then lst : list (nat)
      is this dependent type? *)
Fixpoint mylen {A : Type} (lst : list A) : nat :=
  match lst with
  | nil => 0
  | cons x xs => 1 + mylen xs
  end.
  
Check mylen.

(* this is another "output value implies input property"
  if the length of a list is 0, then its head is None *)
Theorem length0_implies_hdopt_is_none :
  forall A : Type, forall lst : list A,
    mylen lst = 0 -> head_opt lst = None.
Proof.
  intros A. (* assume A is a Type *)
  intros lst. (* assume lst is a list <A> *)
  intros P. (* suppose length lst = 0 *)
  destruct lst. (* un-construct lst and show for each case *)
  (* nil => None constructor for lst
    P is true, Q is true
    P: mylen <nil> = 0
    Q: head_opt <nil> = None *)
  simpl.
  trivial.
  Show Proof.
  (* reflexivity. *)
  (* cons x xs => 1 + mylen xs constructor
    P is false
    P: mylen (cons x xs) = 1 + mylen xs != nil FALSE!
    Q: head_opt (cons x xs) = None FALSE because head_opt (cons ...) = Some ... *)
    simpl.
    discriminate.
    Show Proof.
Qed.

(* we have eq, eq_refl, eq_ind *)

(* in general when destruct on variables in P to solve P -> Q
you must show
   P1 -> Q1 with 1st constructor
   P2 -> Q2 with 2nd constructor
   ...
   
*)

(* bullets can be -, +, *, --, --- *)

